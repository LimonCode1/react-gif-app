{"version":3,"sources":["components/AddCategory.js","helpers/getFecthGifs.js","components/GifGridItem.js","components/GifGrid.js","hook/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setinputValue","onSubmit","e","preventDefault","trim","length","console","log","c","type","value","onChange","target","getFecthGifs","category","a","url","encodeURI","fetch","response","json","data","gifs","map","img","id","title","images","downsized_large","GifGridItem","group","groupEnd","className","src","alt","GifGrid","loading","objeto","setObjeto","useEffect","then","imgs","setTimeout","useFetchGifs","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"mMAEaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EACbC,mBAAS,IADI,mBAC1CC,EAD0C,KAC9BC,EAD8B,KAgBjD,OACC,uBAAMC,SAXc,SAACC,GACrBA,EAAEC,iBACEJ,EAAWK,OAAOC,OAAS,IAC9BC,QAAQC,IAAI,6BAGZV,GAAc,SAACW,GAAD,OAAQT,GAAR,mBAAuBS,OACrCR,EAAc,MAIf,UACC,+CACA,4BAAID,IACJ,uBACCU,KAAK,OACLC,MAAOX,EACPY,SArBuB,SAACT,GAE1BF,EAAcE,EAAEU,OAAOF,c,+BCNZG,EAAY,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAGrBC,EAHqB,iDAG2BC,UACrDH,GAJ0B,+DAMJI,MAAMF,GANF,cAMrBG,EANqB,gBAOJA,EAASC,OAPL,uBAOnBC,EAPmB,EAOnBA,KACFC,EAAOD,EAAKE,KAAI,SAACC,GAAS,IAAD,EAC9B,MAAO,CACNC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,gBAAgBZ,QAZR,kBAqBpBM,GArBoB,4CAAH,sDCGZO,EAAc,SAAC,GAAwB,IAAtBJ,EAAqB,EAArBA,GAAIC,EAAiB,EAAjBA,MAAOV,EAAU,EAAVA,IAMxC,OALAV,QAAQwB,MAAM,kCACdxB,QAAQC,IAAI,OAASkB,GACrBnB,QAAQC,IAAI,WAAamB,GACzBpB,QAAQC,IAAI,QAAUS,GACtBV,QAAQyB,WAEP,sBAAKC,UAAU,kGAAf,UACC,qBAAKC,IAAKjB,EAAKkB,IAAKR,IACpB,4BAAIA,QCRMS,EAAU,SAAC,GAAkB,IAAhBrB,EAAe,EAAfA,SAAe,ECDb,SAACA,GAAc,IAAD,EACbhB,mBAAS,CACpCuB,KAAM,GACNe,SAAS,IAH+B,mBAClCC,EADkC,KAC1BC,EAD0B,KA6BzC,OApBAC,qBAAU,WAGT1B,EAAaC,GAAU0B,MAAK,SAACC,GAC5BC,YAAW,WACVpC,QAAQC,IAAIkC,GACZH,EAAU,CACTjB,KAAMoB,EACNL,SAAS,MAER,UAEF,CAACtB,IAQGuB,EDnB2BM,CAAa7B,GAAjCa,EAT0B,EAShCN,KAAce,EATkB,EASlBA,QAatB,OACC,mCACC,sBAAKJ,UAAU,YAAf,UACC,6BAAKlB,IAEJsB,GAAW,4CACXT,EAAOJ,KAAI,SAACC,GAAD,OACX,cAAC,EAAD,eAA8BA,GAAZA,EAAIC,OALxB,YEGYmB,EA3BM,WAAM,MAEU9C,mBAAS,CAAC,iBAFpB,mBAEnB+C,EAFmB,KAEPhD,EAFO,KAY1B,OACC,qCACC,8CACA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBAEA,6BACEgD,EAAWtB,KAAI,SAACT,GAAD,OACf,cAAC,EAAD,CAAwBA,SAAUA,GAApBA,Y,MCnBnBgC,IAASC,OAAO,cAAC,EAAD,IAAkBC,SAASC,eAAe,W","file":"static/js/main.d2729789.chunk.js","sourcesContent":["import React, { useState } from 'react';\r\nimport PropTypes from 'prop-types';\r\nexport const AddCategory = ({ setCategories }) => {\r\n\tconst [inputValue, setinputValue] = useState('');\r\n\tconst handleInputChange = (e) => {\r\n\t\t// console.log(e.target.value);\r\n\t\tsetinputValue(e.target.value);\r\n\t};\r\n\tconst handleSubmit = (e) => {\r\n\t\te.preventDefault();\r\n\t\tif (inputValue.trim().length > 2) {\r\n\t\t\tconsole.log('ya se envio ðŸ¶ ');\r\n\t\t\t// aca llamar el set categories\r\n\t\t\t// se recibe el setcategories y se agrega el inutvalue al array cada vez que se da enter\r\n\t\t\tsetCategories((c) => [inputValue, ...c]);\r\n\t\t\tsetinputValue('');\r\n\t\t}\r\n\t};\r\n\treturn (\r\n\t\t<form onSubmit={handleSubmit}>\r\n\t\t\t<h2>Add Categorie</h2>\r\n\t\t\t<p>{inputValue}</p>\r\n\t\t\t<input\r\n\t\t\t\ttype=\"text\"\r\n\t\t\t\tvalue={inputValue}\r\n\t\t\t\tonChange={handleInputChange}\r\n\t\t\t></input>\r\n\t\t</form>\r\n\t);\r\n};\r\n\r\nAddCategory.propTypes = {\r\n\t// el metodo .func me permite validar que reciba una funcion el prop\r\n\tsetCategories: PropTypes.func.isRequired,\r\n};\r\n","export const getFecthGifs = async (category) => {\r\n\t// el metodo encodeURI convierte los espacios que le proporcionemos en %20 para que la url sea valida\r\n\t// y de esta manera la peticion a la api no falle\r\n\tconst url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(\r\n\t\tcategory\r\n\t)}&limit=10&api_key=HvDSv0nZxtqqPXOpf4m5XhTF5kWv5gKa`;\r\n\tconst response = await fetch(url);\r\n\tconst { data } = await response.json();\r\n\tconst gifs = data.map((img) => {\r\n\t\treturn {\r\n\t\t\tid: img.id,\r\n\t\t\ttitle: img.title,\r\n\t\t\turl: img.images?.downsized_large.url,\r\n\t\t};\r\n\t});\r\n\t// console.log(gifs);\r\n\t// aca le estamos asignando un nuevo estado a setImages cargando las imagenes que acabamos de obtener\r\n\t// ahora en el array de images estara guardada la data de gifs\r\n\t// setImages(gifs);\r\n\t// ahora como pasamos esta funcion a los helpers en el cap 77 vamos a retornar los gifs antes que enviarlos a setImages\r\n\t// debido a que el useState no se encuentra declarado aca sino en el propio componente\r\n\treturn gifs;\r\n};\r\n// getGifs();\r\n","import React from 'react';\r\n\r\n// aca recibiremos destructurado el array de images para su proceso en el componente\r\nexport const GifGridItem = ({ id, title, url }) => {\r\n\tconsole.group('Datos de array desestructurado');\r\n\tconsole.log('id: ' + id);\r\n\tconsole.log('titulo: ' + title);\r\n\tconsole.log('url: ' + url);\r\n\tconsole.groupEnd();\r\n\treturn (\r\n\t\t<div className=\"animate__animate animate__fadeInRight card w-64 m-8 bg-blue-400 font-sans shadow-2xl rounded-lg\">\r\n\t\t\t<img src={url} alt={title}></img>\r\n\t\t\t<p>{title}</p>\r\n\t\t</div>\r\n\t);\r\n};\r\n","import React from 'react';\r\nimport { useFetchGifs } from '../hook/useFetchGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\nexport const GifGrid = ({ category }) => {\r\n\t// este useState es de ejemplo para comprender el useEffect video 74.\r\n\t// const [count, setCount] = useState(0);\r\n\t// const [imagenes, setImagenes] = useState([]);\r\n\r\n\t// const [images, setImages] = useState([]);\r\n\r\n\t// para renombrar algo que desestructuramos los hacemos:\r\n\t// poniendo el nombrePropiedadDesestructurada : nuevoNombre\r\n\tconst { data: images, loading } = useFetchGifs(category);\r\n\r\n\t// el use effect me permitira ejecutar codigo de manera condicional, util cuando tengo un ciclo infinito de ejecucion\r\n\t// este recibe una funcion la cual es la que quiero ejecutar\r\n\t// useEffect(\r\n\t// \t() => {\r\n\t// \t\t// ahora esta funcion viene de los helpers y como retorna una promise\r\n\t// \t\t// lo que odemos hacer asignarselas al set images\r\n\t// \t\tgetGifs(category).then(setImages);\r\n\t// \t}, // el segundo parametro que recibe es un array de dependencias, si este se encuentra vacio solo se ejecutara una vez el useEffect\r\n\t// \t[category]\r\n\t// );\r\n\r\n\treturn (\r\n\t\t<>\r\n\t\t\t<div className=\"card-grid\">\r\n\t\t\t\t<h3>{category}</h3>\r\n\t\t\t\t{/* el && es una manera corta de evaluar solo una condicion, es un if sin el else */}\r\n\t\t\t\t{loading && <p>Cargando...</p>}\r\n\t\t\t\t{images.map((img) => (\r\n\t\t\t\t\t<GifGridItem key={img.id} {...img} />\r\n\t\t\t\t))}\r\n\t\t\t\t{/* este boton disparara la ejecucion de un useState\r\n\t\t\t\t<h3>{count}</h3>\r\n\t\t\t\t<button onClick={()=> setCount(count + 1)}>setCount +1</button> */}\r\n\t\t\t\t{/*<ol>\r\n\t\t\t\tCuando una funcion no tiene las {} es que tiene un return implicito () */}\r\n\t\t\t\t{/* tarea, mostrar los elementos del use state en lista y que la key sea el id de images */}\r\n\t\t\t\t{/* {images.map(img => (\r\n\t\t\t\t\t\t<li key={img.id}>\r\n\t\t\t\t\t\t\t{img.title}\r\n\t\t\t\t\t\t\t<a href=\"{img.url}\" ></a>\r\n\t\t\t\t\t\t</li>\r\n\t\t\t\t\t))}\r\n\t\t\t\t</ol> */}\r\n\t\t\t\t{/* {images.map(\r\n\t\t\t\t\t(img) => (\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t/* integracion de componente gifGridItem */},\r\n\t\t\t\t(\r\n\t\t\t\t{/* <GifGridItem\r\n\t\t\t\t\t\t\t\tkey={img.id}\r\n\t\t\t\t\t\t\t\t// vamos a enviarle las propiedades individuales al componente,\r\n\t\t\t\t\t\t\t\t// esto con la ayuda de spread ... del array de images en el object img\r\n\t\t\t\t\t\t\t\t{...img}\r\n\t\t\t\t\t\t\t/> */}\r\n\t\t\t\t{/* ) ) )} */}\r\n\t\t\t</div>\r\n\t\t</>\r\n\t);\r\n};\r\n","import { useEffect, useState } from 'react';\r\nimport { getFecthGifs } from '../helpers/getFecthGifs';\r\n\r\nexport const useFetchGifs = (category) => {\r\n\tconst [objeto, setObjeto] = useState({\r\n\t\tdata: [],\r\n\t\tloading: true,\r\n\t});\r\n\t// impelementado el useEffect para que la funcion solo se ejecute una vez\r\n\t// y no quede en un loop infinito\r\n\r\n\t// los efectos no pueden async, debido a que estos siempre esperan algo sincrono\r\n\tuseEffect(() => {\r\n\t\t// aca es donde en realidad se hara la peticion\r\n\t\t// y se traeran las imagenes gif\r\n\t\tgetFecthGifs(category).then((imgs) => {\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tconsole.log(imgs);\r\n\t\t\t\tsetObjeto({\r\n\t\t\t\t\tdata: imgs,\r\n\t\t\t\t\tloading: false,\r\n\t\t\t\t});\r\n\t\t\t}, 3000);\r\n\t\t});\r\n\t}, [category]);\r\n\r\n\t// setTimeout(() => {\r\n\t// \tsetObjeto({\r\n\t// \t\tdata: [1, 2, 3, 4, 5, 6, 7, 8, 9],\r\n\t// \t\tloading: false,\r\n\t// \t});\r\n\t// }, 3000);\r\n\treturn objeto;\r\n};\r\n","import React, { useState } from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\nconst GifExpertApp = () => {\r\n\t// const categories = ['los simpsons', 'futurama', 'dragon ball z'];\r\n\tconst [categories, setCategories] = useState(['los simpsons']);\r\n\t// const handleAdd = () => {\r\n\t// \t// manera de agregar un nuevo elemento al array\r\n\t// \t// setCategories([...categories, 'Sex Education']);\r\n\t// \t// otra manera seria\r\n\t// \tsetCategories((c) => ['Los 100', ...c]);\r\n\t// \t// el setCategories puede tener un callback el cual el primer argumento\r\n\t// \t// es el estado anterior del elemento, pero tiene que regresar un nuevo estado\r\n\t// \tconsole.log(categories);\r\n\t// };\r\n\treturn (\r\n\t\t<>\r\n\t\t\t<h2>GifExpertApp</h2>\r\n\t\t\t<AddCategory setCategories={setCategories} />\r\n\t\t\t<hr />\r\n\t\t\t{/* <button onClick={handleAdd}>Agregar</button> */}\r\n\t\t\t<ol>\r\n\t\t\t\t{categories.map((category) => (\r\n\t\t\t\t\t<GifGrid key={category} category={category} />\r\n\t\t\t\t))}\r\n\t\t\t</ol>\r\n\t\t</>\r\n\t);\r\n};\r\n\r\nexport default GifExpertApp;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport GifExpertApp from './GifExpertApp';\nimport './index.css';\n\nReactDOM.render(<GifExpertApp />, document.getElementById('root'));\n"],"sourceRoot":""}